% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/describe-z-prepare_data.R,
%   R/describe-z-prepare_data2.R
\name{prepare_data}
\alias{prepare_data}
\alias{Formula_Data}
\alias{Data_Vars}
\alias{Formula_Names}
\alias{formula_split}
\alias{clean_dots_formula}
\alias{makeFormula}
\alias{check_data}
\alias{makeNamesNum}
\alias{prepare_data2}
\alias{prepare_data2.formula}
\alias{prepare_data2.data.frame}
\alias{stp25DataObjekt}
\alias{print.stp25data}
\title{Daten und Formula-Objekte}
\usage{
Formula_Data(x, data, subset, na.action = na.pass, ...)

Data_Vars(.data, ..., by = "1")

Formula_Names(x, data = NULL, ...)

formula_split(formula)

clean_dots_formula(formula, data = data, names_data = names(data))

makeFormula(measurevar, groupvars)

check_data(data, vars = NULL)

makeNamesNum(measure, data, meAsNum = grepl("^[[:digit:]]", measure))

prepare_data2(...)

\method{prepare_data2}{formula}(x, data, subset, na.action = na.pass,
  groups = NULL)

\method{prepare_data2}{data.frame}(.data, ..., by = "1", groups = NULL,
  subset, na.action = na.pass)

stp25DataObjekt(data = NULL, measure.vars = NULL, group.vars = NULL,
  condition.vars = NULL, formula = NULL, by = NULL, measure = NULL,
  row_name = NULL, col_name = NULL, measure.class = NULL,
  group.class = NULL, condition.class = NULL, digits = NULL)

\method{print}{stp25data}(x)
}
\arguments{
\item{x}{Formel}

\item{data}{Daten als data.frame}

\item{subset}{geht mit data$variable}

\item{na.action}{nicht aendern default ist na.pass}

\item{...}{nicht benutzt}

\item{.data}{Daten als data.frame}

\item{by}{Gruppen meist als formula ~ x}

\item{formula}{Formula}

\item{measurevar}{Variable  in makeFormula}

\item{groupvars}{Variable in makeFormula}

\item{vars}{in check_data}

\item{measure}{Variablen}

\item{meAsNum}{logical welche sind Zahlen}

\item{groups}{Block codition}

\item{...}{Variablen}

\item{data}{Daten als data.frame}

\item{x}{formel}

\item{data}{daten}

\item{subset}{nicht implementiert}

\item{na.action}{nicht zum aendern}

\item{x}{formel}

\item{data}{daten}

\item{subset}{nicht implementiert}

\item{na.action}{nicht zum aendern}

\item{data}{Daten}

\item{subset}{nicht implementiert}

\item{na.action}{nicht zum aendern}

\item{.data}{daten}

\item{...}{Variablen}

\item{by}{Gruppe}
}
\value{
Formula_Data: list mit "X_data","Y_data","xname","yname",
"Z_data",  "zname", "formula", "condition", "formula.orginal", "digits", "type"

list  data, measure.vars, group.vars, by, measure,
row_name, measure.class, group.class

list mit den Items yname fuer das was vorne steht
und xname fuer das was hinten stehtlist(yname, xname, zname, formula, condition, digits, type)

formula_split: liste  formula, condition, facet_type

clean_dots_formula: formula - Objekt

makeFormula: formula - Objekt

check_data: Logical und wen FALSE ueber cat die  Objekt die falsch sind

string( )

Liste mit Namen und Daten
data,
measure.vars ,
group.vars,
condition.vars,
formula,
by,
measure,
row_name,
col_name,
measure.class,
group.class,
condition.class,
digits
}
\description{
Hilfsfunktionen zum Aufbereiten der Daten.

Formula_Data: Funktion zum aufbereiten der formula. Output List mit neuen Daten.
Die Funktion Formula kan nur \code{Formula(y1 +y2 +y3 ~ .)} aufarbeinten aber nicht
\code{Formula(. ~ y1 +y2 +y3  )} daher wird über \code{clean_dots_formula()} dir Formel vorbereitet

Data_Vars: Funktion zum aufbereiten der Daten Output List mit neuen Daten.

Formula_Names: Namen und Formula-Objekte vorbereiten.

formula_split stolen from mosaic ggformula

clean_dots_formula: Formel bereinigen

makeFormula: Formel erstellen

check_data: prueft ob variablen vorhanden sind bzw ob Faelle NA sind.

makeNamesNum: aus Nummern die Namen extrahieren

Funktion zum Aufbereiten der Daten. Die Daten werden als
tibble::as_tibble(.data) weitergegeben.

Funktion zum Aufbereiten der Daten Output List mit neuen Daten.

Funktion zum Aufbereiten der Daten Output List mit neuen Daten.

stp25DataObjekt Ueberprüft die Objektstrucktur also ob
 measure usw vorhanden ist.
 Die Uebergebenen Daten werden falls notwendig transformiert.

Print Methode
}
\examples{
names(Formula_Data(m1[3]+m2~geschl, varana))


varana2<- head(varana)
varana2 \%>\% Data_Vars(. ~ .)
varana2 \%>\% Data_Vars(alter, m1, m2, by =  ~ geschl)
varana2 \%>\% Data_Vars(alter, m1, m2, by = "geschl")

varana2 \%>\% Data_Vars(1, 2, 3)
varana2 \%>\% Data_Vars(1:3)

names(Formula_Names(m1[3]+m2~geschl, varana))


data <- data.frame(x = NA, y = NA, z = NA)
clean_dots_formula(x ~ y, data)
clean_dots_formula(. ~ x + y, data)
clean_dots_formula(x + y ~ ., data)
clean_dots_formula(~., data)

makeFormula("a", "b")
makeFormula("a", c("b","c"))
makeFormula("a", ~b+c)
makeFormula(c("a", "d"), c("b","c"))


check_data(varana, c("m1", "m2") )
check_data(varana, c("m1", "sex") )


measure <- c("geschl", "1" , "3:5", 1)
 makeNamesNum(measure,  data=varana)

# require(stpvers)
prepare_data2(~ m1 + m2 + m3 + m4, varana)
prepare_data2(~ log(m1) + m2 + m3 + m4, varana)
prepare_data2(~ m1[1] + m2 + m3 + m4, varana)
prepare_data2(~ m1[1] + m2 + m3[4,median] + m4, varana)

#-- Helper
data <- data.frame(x = NA, y = NA, z = NA)
stp25stat:::clean_dots_formula(x ~ y, data)
stp25stat:::clean_dots_formula(. ~ x + y, data)
stp25stat:::clean_dots_formula(x + y ~ ., data)
stp25stat:::clean_dots_formula(~., data)
stp25stat:::formula_split(a+b~x|y)

prepare_data2(varana, m1, m2, m3, m4)
prepare_data2(varana, 4:7)
prepare_data2(varana, m1[1], m2, m3, m4)
prepare_data2(varana, m1[1], m2, m3[4,median], m4)
prepare_data2(varana, m1 , m2, m3=median, m4)
prepare_data2(varana, m1, m2, m3 , m4, by =  ~ geschl)
prepare_data2(varana, m1[4, median], m2, m3 , m4[5], by =  ~ geschl)
}
